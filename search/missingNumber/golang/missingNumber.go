package search

/*
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。



示例 1:

输入: [0,1,3]
输出: 2

示例 2:

输入: [0,1,2,3,4,5,6,7,9]
输出: 8



限制：

1 <= 数组长度 <= 10000

*/

/*
算法解析：
    根据题意，数组可以按照以下规则划分为两部分。

    左子数组： nums[i]=i
    右子数组： nums[i]≠i

    缺失的数字等于 “右子数组的首位元素” 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素”

    初始化： 左边界 i=0 ，右边界 j=len(nums)−1；代表闭区间 [i,j]。
    循环二分： 当 i≤j 时循环 （即当闭区间 [i,j]为空时跳出） ；
        计算中点 m=(i+j)/2，
        若 nums[m]=m，则 “右子数组的首位元素” 一定在闭区间 [m+1,j] 中，因此执行 i=m+1
        若 nums[m]≠m，则 “左子数组的末位元素” 一定在闭区间 [i,m−1]中，因此执行 j=m−1
    返回值： 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可
*/
func missingNumber(nums []int) int {
	i, j := 0, len(nums)-1
	for i <= j {
		m := i + (j-i)/2
		if nums[m] == m {
			i = m + 1
		} else {
			j = m - 1
		}
	}
	return i
}

// // 求和
// func missingNumber(nums []int) int {
//     sum := 0
//     for _,v:=range nums{
//         sum += v
//     }

//     n := len(nums)
//     return (n+1)*n/2 - sum
// }
