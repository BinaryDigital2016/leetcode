/*
颠倒给定的 32 位无符号整数的二进制位。

示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

示例 2：

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
*/

// 如果是两位数字怎么逆序呢？比如 2 4，我们只需要交换两个数字的位置，变成 4 2。
// 如果是四位数字怎么逆序呢？比如 1 2 3 4，同样的我们只需要交换两部分 1 2 和3 4 的数字，变成 3 4 1 2，接下来只需要分别将两部分 3 4 和 1 2 分别逆序，两位数的逆序已经讨论过。
// 如果是八位数字怎么逆序呢？比如 1 2 3 4 5 6 7 8，同样的我们只需要交换两部分1 2 3 4 和 5 6 7 8 的数字，变成 5 6 7 8 1 2 3 4，接下来只需要分别将两部分 5 6 7 8 和 1 2 3 4 分别逆序，四位数的逆序已经讨论过。
// 这道题也可以用这个思想去解决，32 位的数字左半部分何右半部分交换，得到两个 16 位的数字，然后两部分再交换，得到两个 8 位的数字...
// 在二进制中交换两部分，可以用一个技巧，举个例子，对于 x = 1101 交换两部分，我们只需要
// (1100) & x >>> 2 | (0011) & x <<< 2 = (0011)|(0100)= 0111 ，然后就完成了 11 和 01 的交换。
// func reverseBits(num uint32) uint32 {
//     num = ((num & 0xffff0000) >> 16) | ((num & 0x0000ffff) << 16);
//     num = ((num & 0xff00ff00) >> 8) | ((num & 0x00ff00ff) << 8);
//     num = ((num & 0xf0f0f0f0) >> 4) | ((num & 0x0f0f0f0f) << 4);
//     num = ((num & 0xcccccccc) >> 2) | ((num & 0x33333333) << 2);
//     num = ((num & 0xaaaaaaaa) >> 1) | ((num & 0x55555555) << 1);
//     return num;
// }



// 首先先看 ret | (((n>>(31-i)) & 1) << i) 中的 ((n>>(31-i)) & 1) 这一部分做了什么操作。
// 其实这部分所做的操作就是取出 n 的从右往左数的第 x 位的数。
// PS：此处的 31 表示数值类型所占用的内存大小，即：sizeof(uint32_t) = 4 字节 = (4 * 8) 位 = 32 位，之所以为 31 是因为位移操作是从第一位开始的。
// 例如：假设 n = 1101（此处使用 4 位二进制进行演示）
// 当 i = 3 时，就有 ((n >> (3-3)) & 1) -> ((n >> 0) & 1 -> 1101 & 0001 = 0001
// 当 i = 2 时，就有 ((n >> (3-2)) & 1) -> ((n >> 1) & 1 -> 0110 & 0001 = 0000
// 当 i = 1 时，就有 ((n >> (3-1)) & 1) -> ((n >> 2) & 1 -> 0011 & 0001 = 0001
// 当 i = 0 时，就有 ((n >> (3-0)) & 1) -> ((n >> 3) & 1 -> 0001 & 0001 = 0001
// 从上面的例子就可以很清晰的验证我们的想法（其实这部分所做的操作就是取出 n 的从右往左数的第 x 位的数）
// 接下来再看 ret | (((n>>(31-i)) & 1) << i) 中的 << i 这一部分的操作，从上面的分析中我们已知 ((n>>(31-i)) & 1) 就是取 n 的第 31 - i 位，即从右往左按顺序取出。
// 然后再执行 <<i，即表示：将取到的 n 的第 31 - i 位上的数向左位置 i 位，且 i 是从最高位往下最低位走的。
// 因此，(((n>>(31-i)) & 1) << i) 所做的操作就是 ((从最低位往最高位取出 n 对应位上的值) << 将取到的值从最高位往最低位偏移)，其实就是将 n 的第 31 -i 位颠倒，还是用例子演示。
// 例如：假设 n = 1101（此处使用 4 位二进制进行演示）
// 当 i = 3 时，就有 ((n >> (3-3)) & 1) = 0001，然后再进行 0001 << i -> 0001 << 3 = 1000
// 当 i = 2 时，就有 ((n >> (3-2)) & 1) = 0000，然后再进行 0000 << i -> 0000 << 2 = 0000
// 当 i = 1 时，就有 ((n >> (3-1)) & 1) = 0001，然后再进行 0001 << i -> 0001 << 1 = 0010
// 当 i = 0 时，就有 ((n >> (3-0)) & 1) = 0001，然后再进行 0001 << i -> 0001 << 0 = 0001
// 最后就是 ret | (((n>>(31-i)) & 1) << i) 中的 ret | 这一部分做的操作，从上面的分析中可以知道 (((n>>(31-i)) & 1) << i) 的操作就是将 n 的第 31 - i 位颠倒，然后再 ret |，其实就是设置 ret 的第 n 位二进制数。
// 例如：假设 n = 1101（此处使用 4 位二进制进行演示）
// 当 i = 3 时，就有 ((n >> (3-3)) & 1 << 3) = 1000，然后再进行 ret | 1000 -> 0000 | 1000 = 1000
// 当 i = 2 时，就有 ((n >> (3-2)) & 1 << 2) = 0000，然后再进行 ret | 0000 -> 1000 | 0000 = 1000
// 当 i = 1 时，就有 ((n >> (3-1)) & 1 << 1) = 0010，然后再进行 ret | 0010 -> 1000 | 0010 = 1010
// 当 i = 0 时，就有 ((n >> (3-0)) & 1 << 0) = 0001，然后再进行 ret | 0001 -> 1010 | 0001 = 1011
// 最终 n(1101) -> ret(1011)。
// func reverseBits(num uint32) uint32 {
//     var r uint32 = 0
//     for i:=31;i>=0;i--{
//         r = r | ((num>>(31-i)&1)<<i)
//     }
//     return r
// }

func reverseBits(num uint32) uint32 {
    var r uint32 = 0
    for i:=31;i>=0;i--{
        t := num & 1 //取最右一位
        r |= t << i
        num >>= 1 //去掉最右一位
    }
    return r
}
